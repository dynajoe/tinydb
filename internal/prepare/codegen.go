package prepare

import (
	"fmt"
	"reflect"

	"github.com/joeandaverde/tinydb/internal/metadata"
	"github.com/joeandaverde/tinydb/internal/storage"
	vm "github.com/joeandaverde/tinydb/internal/virtualmachine"
	"github.com/joeandaverde/tinydb/tsql/ast"
)

const x = 0

// CreateTableInstructions creates instructions from create table statement
//
// Example from SQLite
// +------+-------------+----+----+----+--------------------------------------+----+---------+
// | addr |   opcode    | p1 | p2 | p3 |                  p4                  | p5 | comment |
// +------+-------------+----+----+----+--------------------------------------+----+---------+
// |    0 | Init        |  0 | 38 |  0 |                                      | 00 |         |
// |    1 | ReadCookie  |  0 |  3 |  2 |                                      | 00 |         |
// |    2 | If          |  3 |  5 |  0 |                                      | 00 |         |
// |    3 | SetCookie   |  0 |  2 |  4 |                                      | 00 |         |
// |    4 | SetCookie   |  0 |  5 |  1 |                                      | 00 |         |
// |    5 | CreateBtree |  0 |  2 |  1 |                                      | 00 |         |
// |    6 | OpenWrite   |  0 |  1 |  0 | 5                                    | 00 |         |
// |    7 | NewRowid    |  0 |  1 |  0 |                                      | 00 |         |
// |    8 | Blob        |  6 |  3 |  0 |                                     | 00 |         |
// |    9 | Insert      |  0 |  3 |  1 |                                      | 08 |         |
// |   10 | Close       |  0 |  0 |  0 |                                      | 00 |         |
// |   11 | Noop        |  0 | 22 |  0 |                                      | 00 |         |
// |   12 | CreateBtree |  0 |  4 |  2 |                                      | 00 |         |
// |   13 | OpenWrite   |  1 |  1 |  0 | 5                                    | 00 |         |
// |   14 | NewRowid    |  1 |  5 |  0 |                                      | 00 |         |
// |   15 | String8     |  0 |  6 |  0 | index                                | 00 |         |
// |   16 | String8     |  0 |  7 |  0 | sqlite_autoindex_foo_1               | 00 |         |
// |   17 | String8     |  0 |  8 |  0 | foo                                  | 00 |         |
// |   18 | Copy        |  4 |  9 |  0 |                                      | 00 |         |
// |   19 | Null        |  0 | 10 |  0 |                                      | 00 |         |
// |   20 | MakeRecord  |  6 |  5 | 11 | BBBDB                                | 00 |         |
// |   21 | Insert      |  1 | 11 |  5 |                                      | 18 |         |
// |   22 | Close       |  0 |  0 |  0 |                                      | 00 |         |
// |   23 | Null        |  0 | 12 | 13 |                                      | 00 |         |
// |   24 | OpenWrite   |  2 |  1 |  0 | 5                                    | 00 |         |
// |   25 | SeekRowid   |  2 | 27 |  1 |                                      | 00 |         |
// |   26 | Rowid       |  2 | 13 |  0 |                                      | 00 |         |
// |   27 | IsNull      | 13 | 35 |  0 |                                      | 00 |         |
// |   28 | String8     |  0 | 14 |  0 | table                                | 00 |         |
// |   29 | String8     |  0 | 15 |  0 | foo                                  | 00 |         |
// |   30 | String8     |  0 | 16 |  0 | foo                                  | 00 |         |
// |   31 | Copy        |  2 | 17 |  0 |                                      | 00 |         |
// |   32 | String8     |  0 | 18 |  0 | CREATE TABLE foo (x int primary key) | 00 |         |
// |   33 | MakeRecord  | 14 |  5 | 19 | BBBDB                                | 00 |         |
// |   34 | Insert      |  2 | 19 | 13 |                                      | 00 |         |
// |   35 | SetCookie   |  0 |  1 |  4 |                                      | 00 |         |
// |   36 | ParseSchema |  0 |  0 |  0 | tbl_name='foo' AND type!='trigger'   | 00 |         |
// |   37 | Halt        |  0 |  0 |  0 |                                      | 00 |         |
// |   38 | Transaction |  0 |  1 |  3 | 0                                    | 01 |         |
// |   39 | Goto        |  0 |  1 |  0 |                                      | 00 |         |
// +------+-------------+----+----+----+--------------------------------------+----+---------+
// Generated by https://ozh.github.io/ascii-tables/
func CreateTableInstructions(stmt *ast.CreateTableStatement) []vm.Instruction {
	instructions := []vm.Instruction{
		// Store 1 in register 0
		{vm.OpInteger, 1, 0, x, x},
		// Open database file cursor at page in [Reg 0] and store cursor at [Cur 0] with 5 columns
		{vm.OpOpenWrite, 0, 0, 5, x},

		// Set up [Reg 1-5]
		// Data is in order of the master table columns
		// Create new table and store root page in [Reg 4]
		{vm.OpCreateTable, 4, x, x, x}, // [Reg 4]
		// Store strings in registers
		{vm.OpString, len("table"), 1, x, "table"},               // [Reg 1]
		{vm.OpString, len(stmt.TableName), 2, x, stmt.TableName}, // [Reg 2]
		{vm.OpString, len(stmt.TableName), 3, x, stmt.TableName}, // [Reg 3]
		{vm.OpString, len(stmt.RawText), 5, x, stmt.RawText},     // [Reg 5]

		// Make record from [Reg 1-5], store in [Reg 6]
		{vm.OpMakeRecord, 1, 5, 6, x},

		// Acquire a rowid for the new record, store in [Reg 7]
		{vm.OpRowID, 0, 7, x, x},

		// Insert record to [Cur 0], record from [Reg 6], key from [Reg 7]
		{vm.OpInsert, 0, 6, 7, x},
		{vm.OpClose, 0, x, x, x},
	}

	return instructions
}

// InsertInstructions generates machine code for insert statement
//
// SQLite Example
//
// Based on: CREATE TABLE company (company_id int PRIMARY KEY, company_name text, description text)
//
// EXPLAIN INSERT INTO company (company_id, company_name, description) VALUES (99, 'hashicorp', NULL)
// +------+-------------+------+----+----+--------------------+----+---------+
// | addr |   opcode    |  p1  | p2 | p3 |         p4         | p5 | comment |
// +------+-------------+------+----+----+--------------------+----+---------+
// |    0 | Init        |    0 | 17 |  0 |                    | 00 |         |
// |    1 | OpenWrite   |    0 |  2 |  0 | 3                  | 00 |         |
// |    2 | OpenWrite   |    1 |  3 |  0 | k(2,,)             | 00 |         |
// |    3 | NewRowid    |    0 |  1 |  0 |                    | 00 |         |
// |    4 | Integer     |   99 |  2 |  0 |                    | 00 |         |
// |    5 | String8     |    0 |  3 |  0 | hashicorp          | 00 |         |
// |    6 | Null        |    0 |  4 |  0 |                    | 00 |         |
// |    7 | Affinity    |    2 |  3 |  0 | DBB                | 00 |         |
// |    8 | SCopy       |    2 |  6 |  0 |                    | 00 |         |
// |    9 | IntCopy     |    1 |  7 |  0 |                    | 00 |         |
// |   10 | MakeRecord  |    6 |  2 |  5 |                    | 00 |         |
// |   11 | NoConflict  |    1 | 13 |  6 | 1                  | 00 |         |
// |   12 | Halt        | 1555 |  2 |  0 | company.company_id | 02 |         |
// |   13 | IdxInsert   |    1 |  5 |  6 | 2                  | 10 |         |
// |   14 | MakeRecord  |    2 |  3 |  8 |                    | 00 |         |
// |   15 | Insert      |    0 |  8 |  1 | company            | 39 |         |
// |   16 | Halt        |    0 |  0 |  0 |                    | 00 |         |
// |   17 | Transaction |    0 |  1 |  5 | 0                  | 01 |         |
// |   18 | Goto        |    0 |  1 |  0 |                    | 00 |         |
// +------+-------------+------+----+----+--------------------+----+---------+
//
// Without Primary Key
// +------+-------------+----+----+----+-----------+----+---------+
// | addr |   opcode    | p1 | p2 | p3 |    p4     | p5 | comment |
// +------+-------------+----+----+----+-----------+----+---------+
// |    0 | Init        |  0 |  9 |  0 |           | 00 |         |
// |    1 | OpenWrite   |  0 |  2 |  0 | 3         | 00 |         |
// |    2 | NewRowid    |  0 |  1 |  0 |           | 00 |         |
// |    3 | Integer     | 99 |  2 |  0 |           | 00 |         |
// |    4 | String8     |  0 |  3 |  0 | hashicorp | 00 |         |
// |    5 | Null        |  0 |  4 |  0 |           | 00 |         |
// |    6 | MakeRecord  |  2 |  3 |  5 | DBB       | 00 |         |
// |    7 | Insert      |  0 |  5 |  1 | company   | 39 |         |
// |    8 | Halt        |  0 |  0 |  0 |           | 00 |         |
// |    9 | Transaction |  0 |  1 |  7 | 0         | 01 |         |
// |   10 | Goto        |  0 |  1 |  0 |           | 00 |         |
// +------+-------------+----+----+----+-----------+----+---------+
func InsertInstructions(pager *storage.Pager, stmt *ast.InsertStatement) []vm.Instruction {
	table, err := metadata.GetTableDefinition(pager, stmt.Table)
	if err != nil {
		return nil
	}
	regsUsed := 0
	regRootPage := 0
	colCount := len(table.Columns)
	cursorIndex := 0
	rowIDReg := regRootPage + 1
	regStartCol := rowIDReg + 1
	regColIdx := regStartCol

	// If there's a returning statement build an easy lookup
	var returnRegs []int
	returningLookup := make(map[string]int)
	for i, c := range stmt.Returning {
		returningLookup[c] = i
	}

	// Generate ops to load registers with column values
	var fields []vm.Instruction
	addField := func(column metadata.ColumnDefinition, value interface{}) {
		// Supplied value and column type must match up
		switch v := value.(type) {
		case string:
			if column.Type != storage.Text {
				panic("type conversion not implemented")
			}
			fields = append(fields, vm.Instruction{vm.OpString, len(v), regColIdx, x, v})
		case int:
			if column.Type != storage.Integer {
				panic("type conversion not implemented")
			}
			fields = append(fields, vm.Instruction{vm.OpInteger, v, regColIdx, x, x})
		case byte:
			if column.Type != storage.Byte {
				panic("type conversion not implemented")
			}
			fields = append(fields, vm.Instruction{vm.OpInteger, int(v), regColIdx, x, x})
		case nil:
			fields = append(fields, vm.Instruction{vm.OpNull, x, regColIdx, x, x})
		default:
			panic("unsupported type")
		}
		if _, ok := returningLookup[column.Name]; ok {
			returnRegs = append(returnRegs, regColIdx)
		}
		regColIdx = regColIdx + 1
	}

	for _, column := range table.Columns {
		expr, ok := stmt.Values[column.Name]
		if !ok {
			addField(column, column.DefaultValue)
			continue
		}

		// TODO: this value type may need to be cast or asserted
		v := vm.Evaluate(expr, nil)
		addField(column, v.Value)
	}

	instructions := append([]vm.Instruction{
		{vm.OpInteger, table.RootPage, regRootPage, x, x},
		{vm.OpOpenWrite, cursorIndex, regRootPage, colCount, x},
		{vm.OpRowID, cursorIndex, rowIDReg, x, x},
	}, fields...)

	regNewRecord := regColIdx + 1
	instructions = append(instructions, []vm.Instruction{
		{vm.OpMakeRecord, regStartCol, colCount, regNewRecord, x},
		{vm.OpInsert, cursorIndex, regNewRecord, rowIDReg, x},
		{vm.OpHalt, x, x, x, x},
	}...)

	regsUsed = regNewRecord + 1

	if len(returnRegs) > 0 {
		regReturnStart := regNewRecord + 1
		for i, r := range returnRegs {
			// Copy the original reg value to the new reg in order to be contiguous
			instructions = append(instructions, vm.Instruction{vm.OpSCopy, r, regReturnStart + i, x, x})
		}
		instructions = append(instructions, []vm.Instruction{
			{vm.OpResultRow, regReturnStart, len(returnRegs), x, x},
		}...)
		regsUsed = regsUsed + len(returnRegs)
	}

	return instructions
}

// SelectInstructions generates instructions from a select statement to generate rows
//
// Query: SELECT * from company WHERE company_name = 'joe'
// +------+-------------+----+----+----+----------+----+---------+
// | addr |   opcode    | p1 | p2 | p3 |    p4    | p5 | comment |
// +------+-------------+----+----+----+----------+----+---------+
// |    0 | Init        |  0 | 11 |  0 |          | 00 |         |
// |    1 | OpenRead    |  0 |  2 |  0 | 3        | 00 |         |
// |    2 | Rewind      |  0 | 10 |  0 |          | 00 |         |
// |    3 | Column      |  0 |  1 |  1 |          | 00 |         |
// |    4 | Ne          |  2 |  9 |  1 | (BINARY) | 52 |         |
// |    5 | Column      |  0 |  0 |  3 |          | 00 |         |
// |    6 | Column      |  0 |  1 |  4 |          | 00 |         |
// |    7 | Column      |  0 |  2 |  5 |          | 00 |         |
// |    8 | ResultRow   |  3 |  3 |  0 |          | 00 |         |
// |    9 | Next        |  0 |  3 |  0 |          | 01 |         |
// |   10 | Halt        |  0 |  0 |  0 |          | 00 |         |
// |   11 | Transaction |  0 |  0 |  7 | 0        | 01 |         |
// |   12 | String8     |  0 |  2 |  0 | joe      | 00 |         |
// |   13 | Goto        |  0 |  1 |  0 |          | 00 |         |
// +------+-------------+----+----+----+----------+----+---------+
func SelectInstructions(pager *storage.Pager, stmt *ast.SelectStatement) []vm.Instruction {
	// TODO: support joins
	table, err := metadata.GetTableDefinition(pager, stmt.From[0].Name)
	if err != nil {
		return nil
	}
	regRootPage := 0
	// TODO: need to generate these out of order and do simple arithmetic to get valid addresses
	readCursor := 0

	instructions := []interface{}{
		vm.Instruction{vm.OpInteger, table.RootPage, regRootPage, x, x},
		vm.Instruction{vm.OpOpenRead, readCursor, regRootPage, len(table.Columns), x},
		func(l labels) vm.Instruction { return vm.Instruction{vm.OpRewind, readCursor, l["halt"], x, x} },
	}

	// Produce a Row
	evaluateRowAddr := len(instructions) - 1
	// Load all columns into registers
	regColStartIdx := regRootPage + 1
	for i := range table.Columns {
		instructions = append(instructions, vm.Instruction{vm.OpColumn, readCursor, i, regColStartIdx + i, x})
	}

	instructions = append(instructions, vm.Instruction{vm.OpResultRow, regColStartIdx, len(table.Columns), x, x})

	// Repeat or halt
	instructions = append(instructions, []interface{}{
		vm.Instruction{vm.OpNext, readCursor, evaluateRowAddr, x, x},
		lbl{"halt", vm.Instruction{vm.OpHalt, x, x, x, x}},
	}...)

	// TODO: load literals into registers
	return build(instructions)
}

type jmp func(labels) vm.Instruction

type lbl struct {
	name string
	vm.Instruction
}

type labels map[string]int

func build(items []interface{}) []vm.Instruction {
	l := make(map[string]int)
	for i, x := range items {
		switch v := x.(type) {
		case lbl:
			l[v.name] = i
		}
	}

	var instructions []vm.Instruction
	for _, x := range items {
		switch v := x.(type) {
		case (func(labels) vm.Instruction):
			instructions = append(instructions, v(l))
		case vm.Instruction:
			instructions = append(instructions, v)
		case lbl:
			instructions = append(instructions, v.Instruction)
		default:
			panic(fmt.Sprintf("unexpected type %v", reflect.TypeOf(x)))
		}
	}
	return instructions
}
